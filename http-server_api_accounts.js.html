<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>http-server/api/accounts.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="OutgoingMessage.html">OutgoingMessage</a></li><li><a href="Game.html">Game</a></li><li><a href="CrashGame.html">CrashGame</a><ul class='members'><li data-type='member' style='display: none;'><a href="CrashGame.html#.CrashGame">CrashGame</a></li><li data-type='member' style='display: none;'><a href="CrashGame.html#.CrashGame">CrashGame</a></li></ul><ul class='methods'><li data-type='method' style='display: none;'><a href="CrashGame.html#publishUpdatedPlayer">publishUpdatedPlayer</a></li><li data-type='method' style='display: none;'><a href="CrashGame.html#handleManualOutDirectives">handleManualOutDirectives</a></li><li data-type='method' style='display: none;'><a href="CrashGame.html#autoOutPlayers">autoOutPlayers</a></li><li data-type='method' style='display: none;'><a href="CrashGame.html#outRemainingPlayers">outRemainingPlayers</a></li><li data-type='method' style='display: none;'><a href="CrashGame.html#outPlayers">outPlayers</a></li></ul></li><li><a href="CrashGameDBTransaction.html">CrashGameDBTransaction</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CrashGameDBTransaction.html#.start">start</a></li><li data-type='method' style='display: none;'><a href="CrashGameDBTransaction.html#createSavePoint">createSavePoint</a></li><li data-type='method' style='display: none;'><a href="CrashGameDBTransaction.html#rollbackToSavePoint">rollbackToSavePoint</a></li></ul></li><li><a href="GameWin.html">GameWin</a><ul class='methods'><li data-type='method' style='display: none;'><a href="GameWin.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="GameWin.html#.calcWonAmount">calcWonAmount</a></li></ul></li><li><a href="SteamItem.html">SteamItem</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SteamItem.html#.fromObject">fromObject</a></li></ul></li><li><a href="module-Games-Game.html">Game</a></li><li><a href="module-Games-SteamItem.html">SteamItem</a></li><li><a href="module-Games-InventoryItem.html">InventoryItem</a></li><li><a href="module-Games-GameWin.html">GameWin</a></li><li><a href="module-Games-GameBet.html">GameBet</a></li><li><a href="module-Games-User.html">User</a></li><li><a href="module-Games-Player.html">Player</a></li></ul><h3>Modules</h3><ul><li><a href="module-access_config.html">access/config</a></li><li><a href="module-access.html">access</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-access.html#~encryptString">encryptString</a></li><li data-type='method' style='display: none;'><a href="module-access.html#.decryptString">decryptString</a></li><li data-type='method' style='display: none;'><a href="module-access.html#~issueJWTToken">issueJWTToken</a></li></ul></li><li><a href="module-broadcasting-server_config.html">broadcasting-server/config</a><ul class='members'><li data-type='member' style='display: none;'><a href="module-broadcasting-server_config.html#.PORT">PORT</a></li></ul></li><li><a href="module-ws-server_ws-clients.html">ws-server/ws-clients</a></li><li><a href="module-database_config.html">database/config</a><ul class='members'><li data-type='member' style='display: none;'><a href="module-database_config.html#.RECONNECTION_ATTEMPTS">RECONNECTION_ATTEMPTS</a></li><li data-type='member' style='display: none;'><a href="module-database_config.html#.RECONNECTION_DELAY">RECONNECTION_DELAY</a></li><li data-type='member' style='display: none;'><a href="module-database_config.html#.DB_CONNECTION_URL">DB_CONNECTION_URL</a></li><li data-type='member' style='display: none;'><a href="module-database_config.html#.DB_TRANSACTIONS_RETRIES_LIMIT">DB_TRANSACTIONS_RETRIES_LIMIT</a></li><li data-type='member' style='display: none;'><a href="module-database_config.html#.PG_POOL_QUERIES_VERBOSE_MODE">PG_POOL_QUERIES_VERBOSE_MODE</a></li></ul></li><li><a href="module-database_connection.html">database/connection</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-database_connection.html#~onClientConnected">onClientConnected</a></li><li data-type='method' style='display: none;'><a href="module-database_connection.html#~reconnect">reconnect</a></li><li data-type='method' style='display: none;'><a href="module-database_connection.html#~createNewClient">createNewClient</a></li><li data-type='method' style='display: none;'><a href="module-database_connection.html#~execRepeatableTransaction">execRepeatableTransaction</a></li></ul></li><li><a href="module-http-server_api_accounts.html">http-server/api/accounts</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~createLocal">createLocal</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~authenticateLocal">authenticateLocal</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~initEmailConfirmation">initEmailConfirmation</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~confirmEmailWithCode">confirmEmailWithCode</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~sendPasswordRecoveryCode">sendPasswordRecoveryCode</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~checkPasswordRecoveryCode">checkPasswordRecoveryCode</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~issueNewPassword">issueNewPassword</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~logout">logout</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~getAccountData">getAccountData</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_accounts.html#~list">list</a></li></ul></li><li><a href="module-http-server_api_oAuth.html">http-server/api/oAuth</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~generateVKRedirect">generateVKRedirect</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~handleVKRedirect">handleVKRedirect</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~generateGoogleRedirect">generateGoogleRedirect</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~handleGoogleRedirect">handleGoogleRedirect</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~generateYandexRedirect">generateYandexRedirect</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~handleYandexRedirect">handleYandexRedirect</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~getOpenIdInstanceByReturnUrl">getOpenIdInstanceByReturnUrl</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~handleSteamRedirect">handleSteamRedirect</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~readUserData">readUserData</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~createUser">createUser</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_oAuth.html#~endAuthentication">endAuthentication</a></li></ul></li><li><a href="module-http-server_api_payments_freekassa.html">http-server/api/payments/freekassa</a></li><li><a href="module-http-server_api_payments_gamemoney.html">http-server/api/payments/gamemoney</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_api_payments_gamemoney.html#~handleDepositHook">handleDepositHook</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_payments_gamemoney.html#~handleDepositHook">handleDepositHook</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_payments_gamemoney.html#~generateDepositRedirectSignature">generateDepositRedirectSignature</a></li></ul></li><li><a href="module-http-server_api_payments.html">http-server/api/payments</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_api_payments.html#~depositRules">depositRules</a></li><li data-type='method' style='display: none;'><a href="module-http-server_api_payments.html#~generateDepositRedirect">generateDepositRedirect</a></li></ul></li><li><a href="module-http-server_config.html">http-server/config</a></li><li><a href="module-http-server.html">http-server</a><ul class='members'><li data-type='member' style='display: none;'><a href="module-http-server.html#.API">API</a></li></ul><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server.html#~startServe">startServe</a></li><li data-type='method' style='display: none;'><a href="module-http-server.html#~shutDown">shutDown</a></li></ul></li><li><a href="module-http-server_middleware_access.html">http-server/middleware/access</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_middleware_access.html#~setAuthCookie">setAuthCookie</a></li><li data-type='method' style='display: none;'><a href="module-http-server_middleware_access.html#~removeAuthCookie">removeAuthCookie</a></li><li data-type='method' style='display: none;'><a href="module-http-server_middleware_access.html#~addAuthorizationDataToRequest">addAuthorizationDataToRequest</a></li><li data-type='method' style='display: none;'><a href="module-http-server_middleware_access.html#~accessUser">accessUser</a></li><li data-type='method' style='display: none;'><a href="module-http-server_middleware_access.html#~accessAdmin">accessAdmin</a></li></ul></li><li><a href="module-http-server_gamemoney-lib.html">http-server/gamemoney-lib</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_gamemoney-lib.html#~generateHmacSignature">generateHmacSignature</a></li><li data-type='method' style='display: none;'><a href="module-http-server_gamemoney-lib.html#~verifyRequestRsaSignature">verifyRequestRsaSignature</a></li><li data-type='method' style='display: none;'><a href="module-http-server_gamemoney-lib.html#~createDeposit">createDeposit</a></li><li data-type='method' style='display: none;'><a href="module-http-server_gamemoney-lib.html#~updateDepositStatus">updateDepositStatus</a></li><li data-type='method' style='display: none;'><a href="module-http-server_gamemoney-lib.html#~handleDepositHook">handleDepositHook</a></li><li data-type='method' style='display: none;'><a href="module-http-server_gamemoney-lib.html#~generateDepositRedirectUrl">generateDepositRedirectUrl</a></li></ul></li><li><a href="module-http-server_health-check.html">http-server/health-check</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_health-check.html#~bytesToMb">bytesToMb</a></li><li data-type='method' style='display: none;'><a href="module-http-server_health-check.html#~memoryUsageInMb">memoryUsageInMb</a></li><li data-type='method' style='display: none;'><a href="module-http-server_health-check.html#~updateState">updateState</a></li><li data-type='method' style='display: none;'><a href="module-http-server_health-check.html#~getState">getState</a></li><li data-type='method' style='display: none;'><a href="module-http-server_health-check.html#.httpMiddleware">httpMiddleware</a></li><li data-type='method' style='display: none;'><a href="module-http-server_health-check.html#.httpEndpoint">httpEndpoint</a></li></ul></li><li><a href="module-http-server_mailer.html">http-server/mailer</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_mailer.html#~sendMail">sendMail</a></li></ul></li><li><a href="module-http-server_plugins_withdrawals_approval.html">http-server/plugins/withdrawals/approval</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_plugins_withdrawals_approval.html#~checkForWithdrawalsBlockers">checkForWithdrawalsBlockers</a></li></ul></li><li><a href="module-http-server_lib.html">http-server/lib</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~freezeObjectDeep">freezeObjectDeep</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~bytesSizeOfObject">bytesSizeOfObject</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~asyncInterval">asyncInterval</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~delay">delay</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~bytesToMb">bytesToMb</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~memoryUsageInMb">memoryUsageInMb</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~compareDeep">compareDeep</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~generateRandomString">generateRandomString</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~minMax">minMax</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~shuffleArray">shuffleArray</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~toFixedPrecisionFloat">toFixedPrecisionFloat</a></li><li data-type='method' style='display: none;'><a href="module-http-server_lib.html#~to2DigitsPrecisionFloat">to2DigitsPrecisionFloat</a></li></ul></li><li><a href="module-logger.html">logger</a></li><li><a href="module-redis-connection_config.html">redis-connection/config</a><ul class='members'><li data-type='member' style='display: none;'><a href="module-redis-connection_config.html#.REDIS_HOST">REDIS_HOST</a></li><li data-type='member' style='display: none;'><a href="module-redis-connection_config.html#.REDIS_PORT">REDIS_PORT</a></li></ul></li><li><a href="module-Games.html">Games</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createLocalAccount">createLocalAccount</a></li><li><a href="global.html#authenticateLocalAccount">authenticateLocalAccount</a></li><li><a href="global.html#fetchAccountData">fetchAccountData</a></li><li><a href="global.html#createAxiosInstance">createAxiosInstance</a></li><li><a href="global.html#createAuthInfrastructure">createAuthInfrastructure</a></li><li><a href="global.html#createWebsocketConnection">createWebsocketConnection</a></li><li><a href="global.html#socketCookieParser">socketCookieParser</a></li><li><a href="global.html#authCookieParser">authCookieParser</a></li><li><a href="global.html#hasAccessUser">hasAccessUser</a></li><li><a href="global.html#hasAccessAdmin">hasAccessAdmin</a></li><li><a href="global.html#util">util</a></li><li><a href="global.html#isMainBroadcastingServer">isMainBroadcastingServer</a></li><li><a href="global.html#MIN_WON_INVENTORY_ITEM_SPAWN_PRICE_USD">MIN_WON_INVENTORY_ITEM_SPAWN_PRICE_USD</a></li><li><a href="global.html#BETTING_PERIOD_MS">BETTING_PERIOD_MS</a></li><li><a href="global.html#COMPLETED_PERIOD_MS">COMPLETED_PERIOD_MS</a></li><li><a href="global.html#CRASH_GAME_FRAMES_DELAY_MS">CRASH_GAME_FRAMES_DELAY_MS</a></li><li><a href="global.html#GAME_LOOP_DELAY_AFTER_ERROR_MS">GAME_LOOP_DELAY_AFTER_ERROR_MS</a></li><li><a href="global.html#%2522your-256-bit-secret%2522">"your-256-bit-secret"</a></li><li><a href="global.html#CURRENT_GAME">CURRENT_GAME</a></li><li><a href="global.html#generateFinalMultipliersGroup">generateFinalMultipliersGroup</a></li><li><a href="global.html#activateFinalMultipliersGroup">activateFinalMultipliersGroup</a></li><li><a href="global.html#generateDepositRedirect">generateDepositRedirect</a></li><li><a href="global.html#list">list</a></li><li><a href="global.html#Accounts">Accounts</a></li><li><a href="global.html#performInventoryItemWithdrawalStatusUpdateNotificationForUser">performInventoryItemWithdrawalStatusUpdateNotificationForUser</a></li><li><a href="global.html#itemsList">itemsList</a></li><li><a href="global.html#fileParser">fileParser</a></li><li><a href="global.html#CONTENT_TYPES%255Bundefined%255D">CONTENT_TYPES[undefined]</a></li><li><a href="global.html#STEAM_ITEM_ICON_URL_HASHES_CACHE%255Bundefined%255D">STEAM_ITEM_ICON_URL_HASHES_CACHE[undefined]</a></li><li><a href="global.html#freekassaIPVerificationMiddleware">freekassaIPVerificationMiddleware</a></li><li><a href="global.html#freekassaHookSignatureVerificationMiddleware">freekassaHookSignatureVerificationMiddleware</a></li><li><a href="global.html#gamemoneyIPVerificationMiddleware">gamemoneyIPVerificationMiddleware</a></li><li><a href="global.html#gamemoneyHookSignatureVerificationMiddleware">gamemoneyHookSignatureVerificationMiddleware</a></li><li><a href="global.html#skinsBackIPVerificationMiddleware">skinsBackIPVerificationMiddleware</a></li><li><a href="global.html#skinsBackHookSignatureVerificationMiddleware">skinsBackHookSignatureVerificationMiddleware</a></li><li><a href="global.html#unitpayIPVerificationMiddleware">unitpayIPVerificationMiddleware</a></li><li><a href="global.html#unitpayHookSignatureVerificationMiddleware">unitpayHookSignatureVerificationMiddleware</a></li><li><a href="global.html#affiliateExists">affiliateExists</a></li><li><a href="global.html#getAffiliate">getAffiliate</a></li><li><a href="global.html#createNewAffiliate">createNewAffiliate</a></li><li><a href="global.html#performRevshareAccrual">performRevshareAccrual</a></li><li><a href="global.html#createDefaultTariff">createDefaultTariff</a></li><li><a href="global.html#getValidMatchingTariff">getValidMatchingTariff</a></li><li><a href="global.html#MENTION_SUGGESTIONS">MENTION_SUGGESTIONS</a></li><li><a href="global.html#searchMentionedUsers">searchMentionedUsers</a></li><li><a href="global.html#filterProhibitedWords">filterProhibitedWords</a></li><li><a href="global.html#EMOJIS_LIST">EMOJIS_LIST</a></li><li><a href="global.html#generateDepositRedirectUrl">generateDepositRedirectUrl</a></li><li><a href="global.html#handleNewPromocodeActivation">handleNewPromocodeActivation</a></li><li><a href="global.html#handleNewCompletedDeposit">handleNewCompletedDeposit</a></li><li><a href="global.html#generateSignature">generateSignature</a></li><li><a href="global.html#verifyHookSignature">verifyHookSignature</a></li><li><a href="global.html#createOrReplaceDeposit">createOrReplaceDeposit</a></li><li><a href="global.html#Status">Status</a></li><li><a href="global.html#createConnection">createConnection</a></li><li><a href="global.html#getConnection">getConnection</a></li><li><a href="global.html#KNOWN_ACQUIRING_SYSTEMS">KNOWN_ACQUIRING_SYSTEMS</a></li><li><a href="global.html#PAYMENT_METHOD_KINDS">PAYMENT_METHOD_KINDS</a></li><li><a href="global.html#PAYMENT_METHOD_ICON_NAMES">PAYMENT_METHOD_ICON_NAMES</a></li><li><a href="global.html#PaymentMethod">PaymentMethod</a></li><li><a href="global.html#depositRules">depositRules</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">http-server/api/accounts.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Implements
 * ---
 * the http-server-endpoints which represents the CRUD actions
 * with user accounts and login+password-based auth / logging out
 * @module http-server/api/accounts
 */
const Express = require( 'express')
const {DB} = require( '../../database/connection.js')
const {error} = require( '../../logger/index.js')
const os = require( 'os')
const {accessUser, accessAdmin, setAuthCookie, removeAuthCookie} = require( '../middleware/access.js')
const {sendMail} = require( '../plugins/mailer.js')
const {codes} = require( 'status-codes')
const {issueJWTToken,ADMIN_PERMISSIONS, USER_PERMISSIONS} = require( '../../access/index.js')
const {parseAffiliateProgramCookies} = require('../middleware/affiliates.js')
const {bindUserToAffiliate} = require('../plugins/affiliates')
const {nats} = require('nats-connection/index.cjs')

const router = Express.Router()

let bcrypt = (os.platform() === 'win32' ? require('bcryptjs') : require('bcrypt'))






/**
 * It creates the local (username, email, password) account.
 * Email and username should be unique
 * @function createLocal
 * @path {POST} /api/accounts/create-local
 * @body {String} email unique, from 5 to 40 chars
 * @body {String} username  unique, from 4 to 40 chars
 * @body {String} password from 8 to 100 chars
 * @code {200} anyway
 * @response {FAIL} status if internal error
 * @response {WRONG_ARGS} status if some field isn't provided
 * @response {accounts.INCORRECT_USERNAME_LENGTH} status if length of trimmed username isn't between 4 and 40
 * @response {accounts.PASSWORD_INCORRECT} status if trimmed password length > 100 or comparison of generated password hash and provided password failed
 * @response {accounts.PASSWORD_TOO_WEAK} status if password is shorter than 6 symbols
 * @response {accounts.EMAIL_INCORRECT} status if trimmed email's length isn't between 5 and 40 chars or if email doesn't match
 * /^(([^&lt;>()\[\]\\.,;:\s@"]+(\.[^&lt;>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
 * @response {accounts.USERNAME_EXISTS} status if username taken
 * @response {accounts.EMAIL_EXISTS} status if email taken
 * @chain this handler
 * @chain {@link module:http-server/api/accounts~authenticateLocal}
 */
const createLocal =  async (req, res, next) => {
    try {

        if (!req.body.email || !req.body.username || !req.body.password) {
            return res.json({status: codes.WRONG_ARGS})
        }


        /** incoming data validation section */
        const trimmed_password = req.body.password.toString().trim()

        /** we use comma to parse mentions in chat messages, so the usernames with comma are prohibited */
        const trimmed_username = req.body.username.toString().trim().replace(/,/g, '')

        const trimmed_email = req.body.email.toString().trim()

        if (trimmed_username.length &lt; 4 || trimmed_username.length > 40) {
            return res.json({status: codes.accounts.INCORRECT_USERNAME_LENGTH})
        }

        if (trimmed_password.length > 100) {
            return res.json({status: codes.accounts.PASSWORD_INCORRECT})
        }

        if (trimmed_password.length &lt; 6) {
            return res.json({status: codes.accounts.PASSWORD_TOO_WEAK})
        }

        if (trimmed_email.length &lt; 5 ||
            trimmed_email.length > 40 ||
            !trimmed_email.match(/^(([^&lt;>()\[\]\\.,;:\s@"]+(\.[^&lt;>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)) {
            return res.json({status: codes.accounts.EMAIL_INCORRECT})
        }
        /** ******************************* */

        const salt_to_hash = await bcrypt.genSalt(10)

        const password_hash = await bcrypt.hash(trimmed_password, salt_to_hash)

        /** instant check of the password hash comparsion with the provided password using bcrypt */
        const comparison_result = await bcrypt.compare(trimmed_password, password_hash)

        /** in this case bcrypt can not compare the created hash with the original password correctly,
         *  so we need to ask user to provide the new password
         */
        if (!comparison_result) return res.json({status: codes.accounts.PASSWORD_INCORRECT})



        try {

            const user = await DB.query(`
                    INSERT INTO users (email, username, password_hash, permissions, created_at) 
                    VALUES ($1, $2, $3, $4, $5) 
                    RETURNING user_id`,
            [trimmed_email, trimmed_username, password_hash, USER_PERMISSIONS, new Date()])
                .then(r => r.rows[0])

            if (req.affiliate_program_data.affiliate_id) {
                bindUserToAffiliate({
                    user_id: user.user_id,
                    ...req.affiliate_program_data
                })
            }



        } catch (e) {

            if (e.constraint === 'users_username_key' || e.constraint === 'username_ref_key') {
                return res.json({status: codes.accounts.USERNAME_EXISTS})
            } else if (e.constraint === 'users_email_key' || e.constraint === 'email_ref_key') {
                return res.json({status: codes.accounts.EMAIL_EXISTS})
            }

            throw e
        }

        /** calling next handler to this request - to authenticate */
        return next()

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}


/**
  * Endpoint to authenticate user if he has the password (account was created as local or email was provided and confirmed)
  * You can provide credentials using "username", "email" or the universal "login" field instead
  * @function authenticateLocal
  * @header {String} host a domain to bind the auth cookie, for e.x. domain.com
  * @path {POST} /api/accounts/authenticate-local
  * @body {String=} email
  * @body {String=} username
  * @body {String} [login= provided username or email]
  * @body {String} password
  * @code {200} anyway
  * @response {OK} status if success (responds with Set-Cookie header)
  * @response {FAIL} status if internal error
  * @response {WRONG_ARGS} status if fields login, username and email are empty
  * @response {WRONG_ARGS} status if password isn't provided
  * @response {INCORRECT_CREDENTIALS} status if password wrong
  * @response {INCORRECT_CREDENTIALS} status if user with provided login/email/username not found
  * @chain this endpoint
  * @chain OR
  * @chain {@link module:http-server/api/accounts~createLocal}
  * @chain this endpoint
  */
const authenticateLocal = async (req, res) => {

    try {

        if ( (!req.body.login &amp;&amp; !req.body.username &amp;&amp; !req.body.email) || !req.body.password ) {
            return res.json({status: codes.WRONG_ARGS})
        }

        /**
         * @inner
         * @type {string}
         */
        const trimmed_password = req.body.password.toString().trim()


        /**
         * @inner
         * @type {string}
         * @desc Selecting between 3 fields when the credentials may be provided
         */
        const trimmed_login = (() => {
            if (req.body.login) return req.body.login.toString().toLowerCase().trim()
            if (req.body.email) return req.body.email.toString().toLowerCase().trim()
            return req.body.username.toString().toLowerCase().trim()
        })()

        if (!trimmed_login) return res.json({status: codes.WRONG_ARGS})

        const {
            /**
             * @desc it is required to compare with provided password using bcrypt.compare()
             * @type String
             */
            password_hash,
            /**
             * @desc it will be packed to an auth token
             * @type {AuthTokenContent}
             * */
            ...auth_token_content
        } = await DB.query(`SELECT 
                user_id, 
                password_hash,
                permissions, 
                admin_permissions_scope 
            FROM users 
            WHERE LOWER(username COLLATE "ru_RU.utf8") = LOWER($1::TEXT COLLATE "ru_RU.utf8") 
               OR LOWER(email COLLATE "ru_RU.utf8") = LOWER($1::TEXT COLLATE "ru_RU.utf8")`, [ trimmed_login ])
            .then(res => res.rows[0] || {})

        /** user not found */
        if (!password_hash || !Object.keys(auth_token_content).length) return res.json({status: codes.accounts.INCORRECT_CREDENTIALS})

        /**
         * @type {Boolean}
         * @desc password comparison result
         * @inner
         * */
        const comparison_result = await bcrypt.compare(trimmed_password, password_hash)

        if (!comparison_result) return res.json({status: codes.accounts.INCORRECT_CREDENTIALS})

        /**
         * @inner
         * @desc Generating a new token which will be used to recognize the user
         * @type {String}
         */
        const encrypted_jwt = await issueJWTToken(auth_token_content)


        /** adding a set-cookie header with the encrypted token */
        setAuthCookie(req, res, encrypted_jwt)

        return res.json({status: codes.OK})

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}


/** it is required to complete signing in / signing up forms via ajax and save passwords
 * after that (imitating form submits)
 */
router.use('/self-redirect', (req, res) => {
    return res.redirect(req.headers.referer ? req.headers.referer : '/')
})



/**
 * If user's email exists and still not confirmed, it mails the confirmation code
 * and saves it to the DB. The code will be resent and replaced on next request
 * by same user
 * @function initEmailConfirmation
 * @path {POST} /api/accounts/init-email-confirmation
 * @chain {@link module:http-server/middleware/access~addAuthorizationDataToRequest}
 * @chain {@link module:http-server/middleware/access~accessUser}
 * @chain this endpoint
 * @code {200} on success result /request error / internal error
 * @response {OK} status if success and code sent
 * @response {FAIL} status if internal error
 * @response {WRONG_ARGS} status if account has no email or re-issuing the auth token needed
 */
const initEmailConfirmation = async (req, res) => {
    try {

        const {user_id} = req.account_data

        /**
         * @inner
         * @type {String}
         * @desc pretty-printed 6-digits code, for example 123456
         * */
        const digital_format_code = `${Math.trunc(Math.random() * 1000000)}`


        /**
         * @desc Updated rows count, 0 if user not found or user's state incorrect
         * @inner
         * @type {{
         *     rowCount: {Number}
         * }}
         */
        const code_saving = await DB.query(`UPDATE users 
            SET email_confirmation_token = $1 
            WHERE (user_id = $2
                       AND email IS NOT NULL 
                       AND email_confirmed IS FALSE )
            RETURNING email`,
        [digital_format_code,
            user_id])


        /** email is already confirmed or not exists (stranger things) */
        if (code_saving.rowCount === 0) {

            const user_state = await DB.query(`SELECT email, email_confirmed FROM users WHERE user_id = $1`, [
                user_id
            ])
                .then(r => r.rows[0])

            if (!user_state) {
                return res.json({status: codes.NOT_FOUND})
            }

            if (user_state.email_confirmed) {
                return res.json({status: codes.ALREADY_DONE})
            }

            if (!user_state.email) {
                return res.json({status: codes.INCORRECT_STATE})
            }

            return res.json({status: codes.FAIL})
        }

        const {email} = code_saving.rows[0]

        /** 123456 >> 123 456 */
        const splitted_to_3_digit_numbers_code = digital_format_code.toString().substr(0,3) + ' ' + digital_format_code.toString().substr(3, 3)

        await sendMail(email, {text: `Код подтверждения почты: ${splitted_to_3_digit_numbers_code}`, subject: 'Подтверждение почты'})


        return res.json({status: codes.OK})
    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}



/**
 * It compares the provided code with the sent one
 * (stored in DB). If they are same, user.email_confirmed
 * bool field becomes true.
 * @function confirmEmailWithCode
 * @path {POST} /api/accounts/confirm-email-with-code
 * @see module:http-server/middleware/access.accessUser
 * @chain {@link module:http-server/middleware/access~addAuthorizationDataToRequest}
 * @chain {@link module:http-server/middleware/access~accessUser}
 * @chain this endpoint
 * @body {Number|String} code
 * @auth {@link module:http-server/middleware/access~accessUser}
 * @code {200} on success result /request error / internal error
 * @response {OK} status if code is correct and email confirmed
 * @response {NOT_FOUND} status if email already confirmed / re-issuing auth token needed / email not exists
 * @response {FAIL} status if internal error
 * @response {WRONG_ARGS} status if no code provided
 */
const confirmEmailWithCode = async (req, res) => {
    try {


        /** '123 456' to '123456' */
        const code = req.body.code ? req.body.code.toString().split(' ').join('') : null

        if (!code) {
            return res.json({status: codes.WRONG_ARGS})
        }


        const {user_id} = req.account_data

        /**
         * @inner
         * @type {{rowCount: Number}}
         * @returns {{ rowCount: 0}} if no user found or user state incorrect
         */
        const comparison_result = await DB.query(`UPDATE users 
            SET email_confirmation_token = NULL, 
                email_confirmed = TRUE 
            WHERE (user_id = $1 
                       AND email_confirmation_token = $2 AND email_confirmed IS FALSE)
            RETURNING email_confirmed`, [user_id, code])

        /** user is not in suitable state */
        if (comparison_result.rowCount === 0) {

            const {email, email_confirmed, email_confirmation_token} = await DB.query(`SELECT email, 
                    email_confirmed, 
                email_confirmation_token FROM users WHERE user_id = $1`, [
                user_id
            ])
                .then(r => r.rows[0])

            if (!email) {
                return res.json({status: codes.INCORRECT_STATE})
            }

            if (!email_confirmation_token) {
                return res.json({status: codes.INCORRECT_STATE})
            }

            if (email_confirmed) {
                return res.json({status: codes.ALREADY_DONE})
            }

            if (email_confirmation_token !== code) {
                return res.json({status: codes.accounts.INCORRECT_CREDENTIALS})
            }

            return res.json({status: codes.NOT_FOUND})
        }

        const {email_confirmed} = comparison_result.rows[0]

        return res.json({status: codes.OK, email_confirmed})


    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}





/**
 * It sends the code to provided email,
 * if with this email exists
 * To prevent registered-emails scanning we should ever response
 * by this route with the same time (for e.x. 2000ms)
 * This is 1 of 3 steps of password recovery
 * @function sendPasswordRecoveryCode
 * @path {POST} /api/accounts/send-password-recovery-code
 * @chain this endpoint
 * @body {String} email the account's email
 * @code {200} anyway
 * @response {FAIL} status if internal error
 * @response {OK} status after constantly 2000ms if code sent or account with provided email not found
 * @response {accounts.EMAIL_INCORRECT} status if trimmed email's length isn't between 5 and 40 chars or if email doesn't match
 * @response {WRONG_ARGS} if some data not passed
 * /^(([^&lt;>()\[\]\\.,;:\s@"]+(\.[^&lt;>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
 * @todo bcrypt is needed to store the hash of code instead of the plain numeric code
 */
const sendPasswordRecoveryCode = async (req, res) => {
    try {

        if (!req.body.email) {
            return res.json({status: codes.WRONG_ARGS})
        }

        const trimmed_email = req.body.email.toString().toLowerCase().trim()

        if (trimmed_email.length &lt; 5 ||
            trimmed_email.length > 40 ||
            !trimmed_email.match(/^(([^&lt;>()\[\]\\.,;:\s@"]+(\.[^&lt;>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)) {
            return res.json({status: codes.accounts.EMAIL_INCORRECT})
        }


        /** black magic - we should ever handle this requests with same time */
        setTimeout(() => {
            return res.json({status: codes.OK})
        }, 2000)


        /**
         * @inner
         * @type {String}
         * @desc 6-digits code, for example 123456
         * */
        const digital_format_code = `${Math.trunc(Math.random() * 1000000)}`

        const user_search_result = await DB.query(`UPDATE users 
                SET password_refresh_token = $1 
                WHERE LOWER(email COLLATE "ru_RU.utf8") = LOWER($2::TEXT COLLATE "ru_RU.utf8")`, [ digital_format_code, trimmed_email ])


        /** if user exists, we have to send the mail,
         * but if it doesn't, we shouldn't say that in the response data */
        if (user_search_result.rowCount !== 0) {
            /** packing the real results into the .action_result variable
             * to send it using our .setTimeout() timer
             */

            /**
             * @inner
             * @type {String}
             * @desc for ex. "123 456"
             */
            const splitted_to_3_digit_numbers_code = digital_format_code.toString().substr(0,3) + ' ' + digital_format_code.toString().substr(3, 3)

            await sendMail(trimmed_email, {text: `Код для восстановления пароля: ${splitted_to_3_digit_numbers_code}`, subject: 'Восстановление пароля'})
        }


    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}


/**
 * This is 2 of 3 steps of password recovery
 * 1. User requests the code mailing
 * 2. User types the code, we compares it and returns the bool val.
 * We still need the email field operating the code to prevent collisions.
 * 3. If code is ok, we show to user the password and password confirmations
 *    inputs.
 * 4. User sends us the new password AND the code from prev step,
 *    cause it is better than use temporary authorization methods.
 * Comparison of the code typed from user and the code stored in DB in .password_recovery_token field (by the provided .email)
 * @function checkPasswordRecoveryCode
 * @path {POST} /api/accounts/check-password-recovery-code
 * @body {String} email
 * @body {String} code
 * @chain this endpoint
 * @code {200} anyway
 * @response {WRONG_ARGS} status, if code or email is not provided
 * @response {accounts.EMAIL_INCORRECT} status if trimmed email's length isn't between 5 and 40 chars or if email doesn't match
 * @response {OK} status if code comparison result is ok
 * @response {FORBIDDEN} status if code is incorrect or user with this email not exists
 * @response {FAIL} status if internal error
 */
const checkPasswordRecoveryCode = async (req, res) => {
    try {

        if (!req.body.code || !req.body.email) return res.json({status: codes.WRONG_ARGS})

        const trimmed_email = req.body.email.toString().trim()
        const trimmed_code = parseInt(req.body.code.split(' ').join('')) /** also trimming */

        if (trimmed_email.length &lt; 5 ||
            trimmed_email.length > 40 ||
            !trimmed_email.match(/^(([^&lt;>()\[\]\\.,;:\s@"]+(\.[^&lt;>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)) {
            return res.json({status: codes.accounts.EMAIL_INCORRECT})
        }

        const db_checking_result = await DB.query('SELECT user_id FROM users WHERE (email = $1 AND password_refresh_token = $2)', [trimmed_email, trimmed_code])

        if (db_checking_result.rows.length > 0) {
            /** code and email are correct, record found */
            return res.json({status: codes.OK})
        } else { /** or not */
            return res.json({status: codes.accounts.INCORRECT_CREDENTIALS})
        }

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}


/**
 * This is the last, 3 of 3 steps of password recovery
 * User sends us his email, the new password AND the code from prev step.
 * @function issueNewPassword
 * @path {POST} /api/accounts/issue-new-token
 * @body {String} email
 * @body {String} code
 * @body {String} new_password
 * @chain this endpoint
 * @chain {@link http-server/api/accounts~authenticateLocal}
 * @response {accounts.PASSWORD_INCORRECT} status if trimmed password length > 100 or comparison of generated password hash and provided password failed
 * @response {accounts.PASSWORD_TOO_WEAK} status if password is shorter than 6 symbols
 * @response {WRONG_ARGS} status, if code or email is not provided
 * @response {accounts.EMAIL_INCORRECT} status if trimmed email's length isn't between 5 and 40 chars or if email doesn't match
 * @response {OK} status if code comparison result is ok
 * @response {FORBIDDEN} status if code is incorrect or user with this email not exists
 * @response {FAIL} status if internal error
 */
const issueNewPassword = async (req, res, next) => {
    try {

        if (!req.body.email || !req.body.code || !req.body.new_password) {
            return res.json({status: codes.WRONG_ARGS})
        }

        const trimmed_email = req.body.email.toString().trim()
        const trimmed_code = parseInt(req.body.code.split(' ').join('')) /** also trimming */
        const trimmed_password = req.body.new_password.toString().trim()

        if (trimmed_email.length &lt; 5 ||
            trimmed_email.length > 40 ||
            !trimmed_email.match(/^(([^&lt;>()\[\]\\.,;:\s@"]+(\.[^&lt;>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)) {
            return res.json({status: codes.accounts.EMAIL_INCORRECT})
        }


        if (trimmed_password.length > 100) {
            return res.json({status: codes.accounts.PASSWORD_INCORRECT})
        }

        if (trimmed_password.length &lt; 6) {
            return res.json({status: codes.accounts.PASSWORD_TOO_WEAK})
        }

        const salt_to_hash = await bcrypt.genSalt(10)

        const password_hash = await bcrypt.hash(trimmed_password, salt_to_hash)

        /** instant check of the password hash comparison with the provided password using bcrypt */
        const comparison_result = await bcrypt.compare(trimmed_password, password_hash)

        /** in this case bcrypt can not compare the created hash with the original password correctly,
         *  so we need to ask user to provide the new password
         */
        if (!comparison_result) return res.json({status: codes.accounts.PASSWORD_INCORRECT})



        const user_update_result = await DB.query('UPDATE users SET password_hash = $1, password_refresh_token = $2 WHERE (email = $3 AND password_refresh_token = $4)',
            [password_hash, null, trimmed_email, trimmed_code])

        if (user_update_result.rowCount !== 0) {

            /** users row updated, can authenticate */
            req.body.password = req.body.new_password
            next()

        } else {
            /** incorrect email or code */
            return res.json({status: codes.accounts.INCORRECT_CREDENTIALS})
        }

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}


/**
 * It adds the set-cookie header with empty content of auth cookie
 * @function logout
 * @path {POST} /api/accounts/logout
 * @code {200} anyway
 * @chain {@link module:http-server/middleware/access~addAuthorizationDataToRequest}
 * @chain {@link module:http-server/middleware/access~accessUser}
 * @chain this endpoint
 * @auth {@link module:http-server/middleware/access~accessUser}
 * @response {FAIL} status if internal error
 * @response {OK} status if auth cookie is removed
 */
const logout = async (req, res) => {
    try {
        removeAuthCookie(req, res)
        return res.json({status: codes.OK})
    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}

/**
 * It returns the account data in JSON format
 * The account's balance calculation uses a SQL template {@link module:http-server/database/balance~insertBalanceCalculationTemplate}
 * @function getAccountData
 * @path {GET} /api/accounts/get-account-data
 * @chain {@link module:http-server/middleware/access~addAuthorizationDataToRequest}
 * @chain {@link module:http-server/middleware/access~accessUser}
 * @chain this endpoint
 * @auth {@link module:http-server/middleware/access~accessUser}
 * @response {FAIL} status if internal error
 * @response {NOT_FOUND} status if user not found using credentials from auth token
 * @response {OK} status if user found
 * @response {User} account_data if status is OK
 */
const getAccountData = async (req, res) => {

    try {

        /**
         * @ignore
         * @inner
         * @type User
         * @see {@link module:http-server/database/balance~insertBalanceCalculationTemplate}
         */
        const account_data = await DB.query(`SELECT user_id, username, email, email_confirmed, avatar_link,
                                        google_id, vk_id, yandex_id, steam_id, telegram_id, admin_permissions_scope, steam_trade_url, permissions, 
                                        CASE WHEN password_hash IS NOT NULL THEN TRUE ELSE FALSE END as has_password, calcBalance(user_id) AS balance
                                        FROM users WHERE (user_id = $1)`,
        [req.account_data.user_id])
            .then(res => res.rows[0])

        /** account may not exists */
        if (!account_data) return res.json({status: codes.NOT_FOUND})

        /**
         * req.account_data contains the decrypted JWT auth token data
         * If user is not an ADMIN, he should not know our permissions syntax
         * */
        if (req.account_data.permissions !== ADMIN_PERMISSIONS) {
            delete account_data.admin_permissions_scope
            delete account_data.permissions
        }

        return res.json({status: codes.OK, account_data})

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }

}


const steam_trade_url_validation_regexp = /https:\/\/steamcommunity.com\/tradeoffer\/new\/\?partner=(\d*?)&amp;token=(.*?)/
const updateSteamTradeUrl = async (req, res) => {
    try {


        const steam_trade_url = req.body.steam_trade_url ? req.body.steam_trade_url.trim() : null


        if (!steam_trade_url || !steam_trade_url_validation_regexp.test(steam_trade_url)) {

            return res.json({status: codes.WRONG_ARGS})
        }

        const {user_id} = req.account_data

        const result = await DB.query(`UPDATE users SET steam_trade_url = $1 WHERE user_id = $2`, [
            steam_trade_url,
            user_id
        ])
            .catch(e => e)

        if (result instanceof Error) {
            if (result.constraint === 'users_steam_trade_url_key') {
                return res.json({status: codes.INCORRECT_STATE})
            } else {
                throw result
            }
        }

        if (!result.rowCount) {
            return res.json({status: codes.NOT_FOUND})
        }

        return res.json({status: codes.OK, updated_steam_trade_url: steam_trade_url})


    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}

const updateAvatar = async (req, res) => {
    try {

        const new_avatar_link = req.body.new_avatar_link ? req.body.new_avatar_link.trim() : null

        if (!new_avatar_link) {
            return res.json({status: codes.WRONG_ARGS})
        }

        const {user_id} = req.account_data

        const result = await DB.query(`UPDATE users SET avatar_link = $1 WHERE user_id = $2 RETURNING avatar_link`, [
            new_avatar_link,
            user_id
        ])

        if (!result.rowCount) {
            return res.json({status: codes.NOT_FOUND})
        }

        const {avatar_link} = result.rows[0]

        return res.json({status: codes.OK, avatar_link})

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}


const updateUsername = async (req, res) => {
    try {

        /** we use comma to parse mentions in chat messages, so the usernames with comma are prohibited */
        const trimmed_username = req.body.new_username ? req.body.new_username.trim().replace(/,/g, '') : null


        if (!trimmed_username) {
            return res.json({status: codes.WRONG_ARGS})
        }

        if (trimmed_username.length &lt; 4 || trimmed_username.length > 40) {
            return res.json({status: codes.accounts.INCORRECT_USERNAME_LENGTH})
        }

        const {user_id} = req.account_data


        const result = await DB.query(`UPDATE users SET username = $1 WHERE user_id = $2 RETURNING username`, [
            trimmed_username,
            user_id
        ]).catch(e => e)

        if (result instanceof Error) {
            if (result.constraint === 'users_username_key' || result.constraint === 'username_ref_key') {
                return res.json({status: codes.accounts.USERNAME_EXISTS})
            } else {
                throw result
            }
        }

        if (!result.rowCount) {
            return res.json({status: codes.NOT_FOUND})
        }

        const {username} = result.rows[0]

        return res.json({status: codes.OK, username})

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}

const updatePassword = async (req, res) => {
    try {

        const {user_id} = req.account_data

        const old_password = req.body.old_password ? req.body.old_password.trim() : null
        const new_password = req.body.new_password ? req.body.new_password.trim() : null
        const new_email = req.body.new_email ? req.body.new_email.trim() : null

        if (!new_password) {
            return res.json({status: codes.WRONG_ARGS})
        }

        if (old_password === new_password) {
            return res.json({status: codes.SAME_VALUE})
        }

        if (new_password.length > 100) {
            return res.json({status: codes.accounts.PASSWORD_INCORRECT})
        }

        if (new_password.length &lt; 6) {
            return res.json({status: codes.accounts.PASSWORD_TOO_WEAK})
        }

        if (new_email &amp;&amp;
            (new_email.length &lt; 5 ||
                new_email.length > 40 || // eslint-disable-next-line no-useless-escape
                !new_email.match(/^(([^&lt;>()\[\]\\.,;:\s@"]+(\.[^&lt;>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)
            )) {
            return { status: codes.accounts.EMAIL_INCORRECT }
        }

        /** ******************************* */

        const salt_to_hash = await bcrypt.genSalt(10)

        const new_password_hash = await bcrypt.hash(new_password, salt_to_hash)

        /** instant check of the password hash comparsion with the provided password using bcrypt */
        const comparison_result = await bcrypt.compare(new_password, new_password_hash)

        /** in this case bcrypt can not compare the created hash with the original password correctly,
         *  so we need to ask user to provide the new password
         */
        if (!comparison_result) return res.json({status: codes.accounts.PASSWORD_INCORRECT})

        const user_data = await DB.query(`SELECT password_hash, email FROM users WHERE user_id = $1`, [
            user_id
        ])
            .then(res => res.rows[0] ? res.rows[0] : {})


        if (!user_data) {
            return res.json({status: codes.NOT_FOUND})
        }

        /** user already has a password. we should authenticate the password update request */
        if (user_data.password_hash) {

            if (!old_password) {
                return res.json({status: codes.WRONG_ARGS})
            }

            const old_password_comparison_result = await bcrypt.compare(old_password, user_data.password_hash)

            if (!old_password_comparison_result) {
                return res.json({status: codes.accounts.INCORRECT_CREDENTIALS})
            }

        }

        if (user_data.email) {
            if (new_email) {
                return res.json({status: codes.ALREADY_DONE})
            }
        }

        const user_updating_result = await DB.query(`UPDATE users 
            SET password_hash = $1,
                email = CASE
                            WHEN $2::TEXT IS NOT NULL
                                THEN $2
                            ELSE
                                email
                    END,
                email_confirmed = CASE
                                      WHEN $2::TEXT IS NOT NULL
                                          THEN FALSE
                                      ELSE
                                          email_confirmed
                    END,
                email_confirmation_token = CASE
                                      WHEN $2::TEXT IS NOT NULL
                                          THEN NULL
                                      ELSE
                                          email_confirmation_token
                    END
                WHERE user_id = $3 
            RETURNING CASE WHEN password_hash IS NOT NULL THEN TRUE ELSE FALSE END as has_password, email, email_confirmed`, [
            new_password_hash,
            new_email,
            user_id,
        ])
            .then(r => r.rows[0])
            .catch(e => e)

        if (user_updating_result instanceof Error) {
            if (user_updating_result.constraint === 'users_email_key' || user_updating_result.constraint === 'email_ref_key') {
                return res.json({status: codes.accounts.EMAIL_EXISTS})
            } else {
                throw user_updating_result
            }
        }

        const {has_password, email, email_confirmed} = user_updating_result


        return res.json({status: codes.OK, has_password, email, email_confirmed})

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}



const publicProfile = async (req, res) => {
    try {

        const username = req.query.username ? req.query.username.trim() : null

        if (!username) {
            return res.json({status: codes.WRONG_ARGS})
        }

        const public_profile = await DB.query(`SELECT 
            username, 
            avatar_link,
            created_at,
            user_id
            FROM users  
            WHERE username = $1`, [
            username
        ])
            .then(r => r.rows[0])

        if (!public_profile) {
            return res.json({status: codes.NOT_FOUND})
        }

        return res.json({status: codes.OK, public_profile})


    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}






/** USERS API */
router.post('/create-local', parseAffiliateProgramCookies, createLocal, authenticateLocal)
router.post('/authenticate-local', authenticateLocal)
router.get('/get-account-data', accessUser, getAccountData)
router.post('/logout', logout)
router.post('/init-email-confirmation', accessUser, initEmailConfirmation)
router.post('/confirm-email-with-code', accessUser, confirmEmailWithCode)
router.post('/send-password-recovery-code', sendPasswordRecoveryCode)
router.post('/check-password-recovery-code', checkPasswordRecoveryCode)
router.post('/issue-new-password', issueNewPassword, authenticateLocal)
router.post('/update-avatar', accessUser, updateAvatar)
router.post('/update-username', accessUser, updateUsername)
router.post('/update-password', accessUser, updatePassword)
router.get('/public-profile', publicProfile)

/** specific routes */
router.post('/update-steam-trade-url', accessUser, updateSteamTradeUrl)



/** ADMINS API */

/**
 * @desc It returns sorted &amp; filtered &amp; paginated list of user accounts
 * @function list
 * @path {GET} /api/accounts/list
 * @chain {@link module:http-server/middleware/access~addAuthorizationDataToRequest}
 * @chain {@link module:http-server/middleware/access~accessAdmin}
 * @chain this endpoint
 * @response {OK} status - if success
 * @response {User[]} [accounts] - if success
 * @response {FORBIDDEN} status - if auth cookie doesnt contain the .ACCOUNTS permissions scope
 * @response {FAIL} status - if internal error
 */
const list = async (req, res) => {
    try {

        const user_id = req.query.user_id &amp;&amp; !isNaN(Number(req.query.user_id)) ? Number(req.query.user_id) : null
        const email = req.query.email ? `%${req.query.email.trim()}%` : null
        const username = req.query.username ? `%${req.query.username.trim()}%` : null
        const created_at_from = req.query.created_at &amp;&amp; req.query.created_at.from &amp;&amp; new Date(req.query.created_at.from).toString() !== 'Incorrect Date' ? new Date(req.query.created_at.from) : null
        const created_at_to = req.query.created_at &amp;&amp; req.query.created_at.to &amp;&amp; new Date(req.query.created_at.to).toString() !== 'Incorrect Date' ? new Date(req.query.created_at.to) : null
        const deposits_sum_from = req.query.deposits_sum &amp;&amp; req.query.deposits_sum.from ? parseFloat(req.query.deposits_sum.from) : null
        const deposits_sum_to = req.query.deposits_sum &amp;&amp; req.query.deposits_sum.to ? parseFloat(req.query.deposits_sum.to) : null
        const bets_sum_from = req.query.bets_sum &amp;&amp; req.query.bets_sum.from ? parseFloat(req.query.bets_sum.from) : null
        const bets_sum_to = req.query.bets_sum &amp;&amp; req.query.bets_sum.to ? parseFloat(req.query.bets_sum.to) : null
        const inventory_items_count_from = req.query.inventory_items_count &amp;&amp; req.query.inventory_items_count.from ? parseInt(req.query.inventory_items_count.from) : null
        const inventory_items_count_to = req.query.inventory_items_count_to &amp;&amp; req.query.inventory_items_count.to ? parseInt(req.query.inventory_items_count.to) : null
        const steam_id = req.query.steam_id &amp;&amp; String(req.query.steam_id).trim() ? String(req.query.steam_id).trim() : null
        const holdings_sum_from = req.query.holdings_sum &amp;&amp; req.query.holdings_sum.from ? Number(req.query.holdings_sum.from) : null
        const holdings_sum_to = req.query.holdings_sum &amp;&amp; req.query.holdings_sum.to ? Number(req.query.holdings_sum.to) : null
        const fiat_balance_from = req.query.fiat_balance &amp;&amp; req.query.fiat_balance.from ? Number(req.query.fiat_balance.from) : null
        const fiat_balance_to = req.query.fiat_balance &amp;&amp; req.query.fiat_balance.to ? Number(req.query.fiat_balance.to) : null
        const inventory_items_prices_sum_from = req.query.inventory_items_prices_sum &amp;&amp; req.query.inventory_items_prices_sum.from ? Number(req.query.inventory_items_prices_sum.from) : null
        const inventory_items_prices_sum_to = req.query.inventory_items_prices_sum &amp;&amp; req.query.inventory_items_prices_sum.to ? Number(req.query.inventory_items_prices_sum.to) : null

        const offset = req.query.offset &amp;&amp; !isNaN(parseInt(req.query.offset)) ? parseInt(req.query.offset) : 0
        const limit = req.query.limit &amp;&amp; !isNaN(parseInt(req.query.limit)) ? parseInt(req.query.limit) : 50

        const sorting_property = req.query.sorting_property &amp;&amp; req.query.sorting_property.trim() ? req.query.sorting_property.trim() : 'created_at'
        const sorting_direction = req.query.sorting_direction &amp;&amp; req.query.sorting_direction.trim() ? req.query.sorting_direction.trim() : 'ASC'



        const accounts = await DB.query(`WITH found_users AS (SELECT u.*, 
                                                            (SELECT count(*) FROM deposits d WHERE d.user_id = u.user_id AND d.status = 'COMPLETED')::INT as deposits_count,
                                                            (SELECT COALESCE(sum(d.net_amount_usd), 0.00) FROM deposits d WHERE d.status = 'COMPLETED' 
                                                                                                                            AND d.user_id = u.user_id)::NUMERIC(16, 2) AS deposits_sum,
                                                            (SELECT count(*) FROM bets b WHERE b.user_id = u.user_id)::INT AS bets_count,
                                                            (SELECT COALESCE(sum(b.amount), 0.00) FROM bets b WHERE b.user_id = u.user_id)::NUMERIC(16, 2) AS bets_sum,
                                                            (SELECT count(*) 
                                                                FROM inventory_items ii 
                                                                WHERE ii.user_id = u.user_id 
                                                                  AND ii.status IN ('STORED', 'WITHDRAW_PROCESSING', 'AWAITING_WITHDRAW_CONFIRMATION')
                                                            )::INT AS inventory_items_count,
                                                            (SELECT COALESCE(sum(ii.price), 0.00) 
                                                                FROM inventory_items ii 
                                                                WHERE ii.user_id = u.user_id 
                                                                  AND ii.status IN ('STORED', 'WITHDRAW_PROCESSING', 'AWAITING_WITHDRAW_CONFIRMATION')
                                                            )::NUMERIC(16, 2) AS inventory_items_prices_sum,
                                                            calcbalance(u.user_id) as fiat_balance
                                                            FROM users u 
                                                            WHERE (
                                                                ($1::INT IS NULL OR u.user_id::INT = $1::INT)
                                                                AND
                                                                ($2::TEXT IS NULL OR LOWER(u.email::TEXT COLLATE "ru_RU.utf8") LIKE LOWER($2::TEXT COLLATE "ru_RU.utf8"))
                                                                AND
                                                                ($3::TEXT IS NULL OR LOWER(u.username::TEXT COLLATE "ru_RU.utf8") LIKE LOWER($3::TEXT COLLATE "ru_RU.utf8"))
                                                                AND
                                                                ( ($4::TIMESTAMPTZ IS NULL OR $5::TIMESTAMPTZ IS NULL) 
                                                                    OR date_trunc('day', u.created_at) >= date_trunc('day', $4::TIMESTAMPTZ) 
                                                                           AND 
                                                                            date_trunc('day', u.created_at) &lt;= date_trunc('day', $5::TIMESTAMPTZ)  )
                                                                AND
                                                                ($6::TEXT IS NULL OR u.steam_id::TEXT = $6::TEXT)
                                                            )
                                                        ),
                                                        aggregated_values AS (
                                                            SELECT *, (fiat_balance + inventory_items_prices_sum)::NUMERIC(16,2) AS holdings_sum FROM found_users
                                                        )
                                                        /* third section which allows to use aggregated fields to order or filtering */
                                                        SELECT *,  (count(*) OVER())::INTEGER AS total_found
                                                        FROM aggregated_values
                                                        WHERE (
                                                            ($7::NUMERIC(16,2) IS NULL OR deposits_sum >= $7::NUMERIC(16,2))  
                                                            AND
                                                            ($8::NUMERIC(16,2) IS NULL OR deposits_sum &lt;= $8::NUMERIC(16,2))
                                                            AND
                                                            ($9::NUMERIC(16,2) IS NULL OR bets_sum >= $9::NUMERIC(16,2))  
                                                            AND
                                                            ($10::NUMERIC(16,2) IS NULL OR bets_sum &lt;= $10::NUMERIC(16,2))
                                                            AND
                                                            ($11::INT IS NULL OR inventory_items_count >= $11::INT)
                                                            AND
                                                            ($12::INT IS NULL OR inventory_items_count &lt;= $11::INT)
                                                            AND
                                                            ($13::NUMERIC(16,2) IS NULL OR (fiat_balance + inventory_items_prices_sum)::NUMERIC(16,2) >= $13::NUMERIC(16,2)) /** holdings sum */
                                                            AND
                                                            ($14::NUMERIC(16,2) IS NULL OR (fiat_balance + inventory_items_prices_sum)::NUMERIC(16,2) &lt;= $14::NUMERIC(16,2)) /** holdings sum  */
                                                            AND
                                                            ($15::NUMERIC(16,2) IS NULL OR fiat_balance >= $15::NUMERIC(16,2)) /** fiat balance */
                                                                   AND
                                                            ($16::NUMERIC(16,2) IS NULL OR fiat_balance &lt;= $16::NUMERIC(16,2)) /** fiat balance */
                                                               AND
                                                            ($17::NUMERIC(16,2) IS NULL OR inventory_items_prices_sum >= $17::NUMERIC(16,2)) /** stored inventory items prices sum */
                                                                   AND
                                                            ($18::NUMERIC(16,2) IS NULL OR inventory_items_prices_sum &lt;= $18::NUMERIC(16,2)) /** stored inventory items prices sum */
                                                        )
                                                        ORDER BY ${sorting_property} ${sorting_direction}
                                                        OFFSET $19
                                                        LIMIT $20
                                                                  `, [
            user_id,
            email,
            username,
            created_at_from,
            created_at_to,
            steam_id,
            deposits_sum_from,
            deposits_sum_to,
            bets_sum_from,
            bets_sum_to,
            inventory_items_count_from,
            inventory_items_count_to,
            holdings_sum_from,
            holdings_sum_to,
            fiat_balance_from,
            fiat_balance_to,
            inventory_items_prices_sum_from,
            inventory_items_prices_sum_to,
            offset,
            limit,
        ])
            .then(res => res.rows)


        return res.json({status: codes.OK, accounts})

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}

const detailed = async (req, res) => {
    try {

        const username = req.query.username &amp;&amp; req.query.username.trim() ? req.query.username.trim() : null

        const user_id = req.query.user_id &amp;&amp; String(req.query.user_id).trim() ? req.query.user_id.trim() : null

        if (!username &amp;&amp; !user_id) {
            return res.json({status: codes.WRONG_ARGS})
        }

        const detailed = await DB.query(`
                SELECT user_id, 
                       username,
                       (SELECT ARRAY( 
                           SELECT row_to_json(notes) 
                           FROM (
                               SELECT n.*,
                                      u2.username    AS author_username,
                                      u2.avatar_link AS author_avatar_link
                               FROM notes n
                                        LEFT JOIN users u2
                                                  ON (n.author_user_id = u2.user_id)
                               WHERE n.user_id = u.user_id
                                    
                       ) notes
                                   )
                       ) AS notes,
                       (SELECT ARRAY(
                                       SELECT row_to_json(chat_mutings)
                                       FROM (
                                                SELECT ucm.*,
                                                       u2.username    AS muted_by_username,
                                                       u2.avatar_link AS muted_by_avatar_link
                                                FROM user_chat_mutings ucm
                                                         LEFT JOIN users u2
                                                                   ON (ucm.muted_by_user_id = u2.user_id)
                                                WHERE ucm.user_id = u.user_id
                                                ORDER BY ucm.created_at ASC

                                            ) chat_mutings
                                   )
                       ) AS chat_mutings
                FROM users u 
                WHERE username = $1 
                   OR user_id = $2`, [
            username,
            user_id
        ]).then(r => r.rows[0])

        if (!detailed) {
            return res.json({status: codes.NOT_FOUND})
        }

        return res.json({status: codes.OK, detailed})

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}

const addNote = async (req, res) => {
    try {

        const {text, user_id} = req.body

        if (!text || !text.trim() || !user_id) {
            return res.json({status: codes.WRONG_ARGS})
        }

        const author_user_id = req.account_data.user_id

        const note = await DB.query(`
            WITH inserted_notes AS (
                INSERT INTO notes (text, user_id, author_user_id)
                VALUES ($1, $2, $3)
                RETURNING *
            ) SELECT n.*,
                     u.username AS author_username,
                     u.avatar_link AS author_avatar_link
                FROM inserted_notes n 
                LEFT JOIN users u 
                    ON (n.author_user_id = u.user_id)
            
        `, [
            text,
            user_id,
            author_user_id
        ])
            .then(r => r.rows[0])

        nats.publish('SCOPED.ACCOUNTS.NEW_NOTE', {note})

        return res.json({status: codes.OK, note})

    } catch (e) {
        error(`${req.originalUrl} err:`, e)
        return res.json({status: codes.FAIL})
    }
}




router.get('/list', accessAdmin({ACCOUNTS: true}), list)
router.get('/detailed', accessAdmin({ACCOUNTS: true}), detailed)
router.post('/add-note', accessAdmin({ACCOUNTS: true}), addNote)


module.exports = router



</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.5</a> on Mon Feb 08 2021 15:54:23 GMT+0300 (Moscow Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
